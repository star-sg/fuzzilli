diff --git a/BUILD.gn b/BUILD.gn
index 4e429908762..ce1a66eeacc 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -25,6 +25,8 @@ target_is_simulator = (target_cpu != v8_target_cpu && !v8_multi_arch_build) ||
 emit_builtins_as_inline_asm = is_win && is_clang
 
 declare_args() {
+  v8_jit_picker = false
+
   # Print to stdout on Android.
   v8_android_log_stdout = false
 
@@ -1048,6 +1050,11 @@ config("features") {
     ":cppgc_header_features",
   ]
 
+  if (v8_jit_picker) {
+    defines += [ "V8_FUZZILLI" ]
+    defines += [ "V8_JITPICKER" ]
+  }
+
   if (cppgc_enable_verify_heap) {
     defines += [ "CPPGC_VERIFY_HEAP" ]
   }
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index ce1e6e7c741..ecc0f078e33 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -6159,7 +6159,20 @@ int Shell::Main(int argc, char* argv[]) {
         // to be flushed after every execution
         fflush(stdout);
         fflush(stderr);
+#ifdef V8_JITPICKER
+        struct {
+            int status;
+            uint32_t execHash;
+            uint32_t execHashInputs;
+        } s;
+        s.status = status;
+        s.execHash = i::FuzzilliExtension::execHash;
+        s.execHashInputs = 0;  // execHashInputs not tracked for now
+        i::FuzzilliExtension::execHash = 0;
+        CHECK_EQ(write(REPRL_CWFD, &s, 12), 12);
+#else
         CHECK_EQ(write(REPRL_CWFD, &status, 4), 4);
+#endif // V8_JITPICKER
         sanitizer_cov_reset_edgeguards();
         if (options.fuzzilli_enable_builtins_coverage) {
           i::BasicBlockProfiler::Get()->ResetCounts(
diff --git a/src/fuzzilli/fuzzilli.cc b/src/fuzzilli/fuzzilli.cc
index 1eef8d15f22..29881388136 100644
--- a/src/fuzzilli/fuzzilli.cc
+++ b/src/fuzzilli/fuzzilli.cc
@@ -12,6 +12,7 @@
 #include "src/execution/isolate.h"
 #include "src/fuzzilli/cov.h"
 #include "src/sandbox/sandbox.h"
+#include "v8-object.h"
 #include "src/sandbox/testing.h"
 
 #ifdef V8_OS_LINUX
@@ -22,6 +23,8 @@
 namespace v8 {
 namespace internal {
 
+uint32_t FuzzilliExtension::execHash = 0;
+
 v8::Local<v8::FunctionTemplate> FuzzilliExtension::GetNativeFunctionTemplate(
     v8::Isolate* isolate, v8::Local<v8::String> str) {
   return v8::FunctionTemplate::New(isolate, FuzzilliExtension::Fuzzilli);
@@ -127,6 +130,39 @@ void FuzzilliExtension::Fuzzilli(const FunctionCallbackInfo<Value>& info) {
     }
     fprintf(fzliout, "%s\n", *string);
     fflush(fzliout);
+  } else if (strcmp(*operation, "FUZZILLI_RANDOM") == 0) {
+    std::unique_ptr<base::RandomNumberGenerator> rng;
+    rng = std::make_unique<base::RandomNumberGenerator>();
+    double p = rng->NextDouble();
+    info.GetReturnValue().Set(v8::Number::New(info.GetIsolate(), p));
+  } else if (strcmp(*operation, "FUZZILLI_HASH") == 0) {
+      v8::Isolate* isolate = info.GetIsolate();
+      auto context = isolate->GetCurrentContext();
+      uint32_t cur_hash = execHash;
+
+      auto arg = info[1];
+
+      if (arg->IsNull()) cur_hash += 1;
+      else if (arg->IsTrue()) cur_hash += 2;
+      else if (arg->IsFalse()) cur_hash += 4;
+      else if (arg->IsUndefined()) cur_hash += 8;
+      else if (arg->IsString()) cur_hash += 16;
+      else if (arg->IsNumber()) {
+          cur_hash += 32;
+          double tmp = arg->NumberValue(context).FromMaybe(1.0);
+          if (std::isnan(tmp)) tmp = 1.0;
+          if (std::isinf(tmp)) tmp = 1.0;
+          uint32_t low, high;
+          memcpy(&low, &tmp, sizeof(uint32_t));
+          memcpy(&high, ((char*)&tmp) + sizeof(uint32_t), sizeof(uint32_t));
+          cur_hash += low;
+          cur_hash += high;
+      } else if (arg->IsObject()) cur_hash += 64;
+
+      cur_hash = (cur_hash << 30) | ((cur_hash >> 1) & 0x3FFFFFFF);
+      execHash = cur_hash;
+
+      fprintf(stderr, "Hash: %u\n", cur_hash);
   }
 }
 
diff --git a/src/fuzzilli/fuzzilli.h b/src/fuzzilli/fuzzilli.h
index be88a3504f1..78e7a99dfbc 100644
--- a/src/fuzzilli/fuzzilli.h
+++ b/src/fuzzilli/fuzzilli.h
@@ -29,6 +29,8 @@ class FuzzilliExtension : public v8::Extension {
       v8::Isolate* isolate, v8::Local<v8::String> name) override;
   static void Fuzzilli(const v8::FunctionCallbackInfo<v8::Value>& info);
 
+  static uint32_t execHash;
+
  private:
   static const char* BuildSource(char* buf, size_t size, const char* fun_name) {
     base::SNPrintF(base::Vector<char>(buf, static_cast<int>(size)),
